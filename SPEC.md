# SPEC: Agent Safety Kit (`agsekit`)

Философская рамка проекта вынесена в отдельные документы:
- `philosophy-ru.md` (русский)
- `philosophy.md` (English)

Этот `SPEC.md` описывает текущее техническое состояние реализации и связывает его с целевой философией.

## 1. Продукт: зачем он нужен

`Agent Safety Kit` — это CLI-инструмент для безопасной работы с консольными AI-агентами (`qwen`, `codex`, `claude`, `codex-glibc`) через изоляцию в Multipass VM и регулярные инкрементальные бэкапы на хосте.

Ключевая пользовательская проблема:
- агент может повредить проект (удалить файлы, сломать рабочую копию, внести нежелательные изменения);
- стандартные «sandbox» режимы агентов часто недостаточны;
- пользователю нужен воспроизводимый, управляемый workflow с откатом и минимальной ручной рутины.

Основная идея решения:
- агент всегда исполняется внутри VM;
- рабочая папка проекта монтируется в VM;
- на хосте автоматически создаются снапшоты (`rsync` + `--link-dest`) в отдельной backup-папке;
- VM, mounts и агенты описаны в YAML-конфиге;
- вся операционная рутина (подготовка, создание VM, установка агентов, запуск, backup cleanup) сведена в одну CLI.

Принятое threat-model допущение:
- агент по умолчанию считается потенциально опасным (вероятностное поведение, а не гарантированно безопасная логика);
- безопасность должна обеспечиваться архитектурными ограничениями (изоляция + лимиты + бэкапы), а не доверием к агенту.

## 2. Для кого и какие user stories закрывает

Целевая аудитория:
- обычные разработчики, использующие консольных AI-агентов в реальных проектах;
- команды, где важно быстро восстановиться после неудачного прогона агента;
- энтузиасты и пользователи, которым нужна «инженерная» дисциплина запуска агентов без погружения в сложный DevOps/tooling.

Типовые user stories:
1. Как пользователь, я хочу один раз подготовить окружение (`prepare`, `create-vms`, `mount`) и дальше запускать агента одной командой.
2. Как пользователь, я хочу, чтобы при запуске агента автоматически работали фоновые бэкапы и не требовали ручного контроля.
3. Как пользователь, я хочу хранить инфраструктуру в YAML, чтобы конфигурация была воспроизводимой, переносимой и версионируемой.
4. Как пользователь, я хочу устанавливать окружение в VM декларативно (`install` bundles), чтобы не дублировать shell-скрипты.
5. Как пользователь, я хочу интерактивный режим для редких операций, но полноценный non-interactive режим для автоматизации.
6. Как пользователь, я хочу быстро управлять жизненным циклом VM и туннелями (`start/stop/destroy`, `portforward`, `systemd`).

## 3. Границы ответственности (что инструмент делает и чего не делает)

Инструмент делает:
- оркестрацию VM через Multipass;
- монтирование директорий и запуск агентов внутри VM;
- snapshot-like резервные копии на хосте;
- установку базовых пакетов/агентов через Ansible;
- управление локальным сервисом port-forwarding через user-level systemd.

Инструмент не делает:
- не обеспечивает криптографическую защиту данных и не заменяет полноценный секрет-менеджмент;
- не «лечит» уязвимости самих AI-агентов;
- не меняет ресурсы уже существующей VM (только сообщает mismatch);
- не заменяет Git/remote backups (это локальный operational safety слой).

## 4. Архитектурные решения и rationale

### 4.1 Почему VM-first, а не container-first
- контейнеры делят ядро хоста, поэтому baseline-изоляция слабее, чем у полноценной VM;
- агентный workload часто сам должен работать с Docker (собирать образы, запускать compose/сервисы);
- запуск Docker внутри «защитного» контейнера обычно приводит к ослаблению изоляции (privileged mode или проброс docker socket);
- VM позволяет сохранить и изоляцию, и валидный DevOps-сценарий «контейнеры как целевая среда разработки».

### 4.2 Почему Multipass
- минимальный порог входа для Ubuntu VM;
- простые команды (`launch`, `exec`, `mount`, `info`);
- достаточно для изоляции агентного процесса от хоста;
- хорошо сочетается с Ansible через `theko2fi.multipass` connection plugin.

### 4.3 Почему бэкапы на хосте, а не «снэпшоты VM»
- целевой объект защиты — проектные файлы на хосте;
- backup-цепочка хранится рядом с проектом и легко восстанавливается;
- hardlink-инкременты экономят место;
- можно чистить историю гибкими политиками (`tail`/`thin`).

### 4.4 Почему YAML-конфиг
- единый источник правды для VM/mount/agent;
- удобно ревьюить, хранить в репозитории и переносить между машинами;
- CLI поддерживает явное разрешение пути (`--config`/`CONFIG_PATH`/default path).

### 4.5 Почему Ansible для установки ПО
- идемпотентность и воспроизводимость;
- декларативный слой над ручными shell-командами;
- простой путь расширять install bundles и agent installers.

### 4.6 Почему интерактивный fallback
- снижает порог входа для «ручного» пользователя;
- при этом не ломает автоматизацию (флаг `--non-interactive` полностью отключает prompts);
- команда без аргументов превращается в guided menu, а не в «глухую» ошибку.

## 5. Компоненты системы

- `agsekit_cli/cli.py`
  - регистрация команд;
  - логика интерактивного fallback;
  - глобальный вход `main()`.
- `agsekit_cli/config.py`
  - загрузка YAML;
  - dataclass-модели (`VmConfig`, `MountConfig`, `AgentConfig`, `PortForwardingRule`);
  - валидация/нормализация.
- `agsekit_cli/vm.py`
  - проверка Multipass;
  - сравнение существующих VM и проверка ресурсов хоста;
  - запуск VM;
  - port-forward аргументы;
  - proxychains helper transfer.
- `agsekit_cli/vm_prepare.py`
  - host SSH keypair;
  - подготовка VM (authorized_keys, known_hosts, base packages, bundles).
- `agsekit_cli/mounts.py`
  - mount/umount wrappers;
  - поиск mount по пути (longest-prefix).
- `agsekit_cli/backup.py`
  - one-off/repeated backup;
  - cleanup (`tail`, `thin`);
  - `.backupignore` parsing;
  - progress bar;
  - `.inodes` manifest.
- `agsekit_cli/agents.py`
  - выбор mount/VM;
  - сбор shell-команды запуска;
  - merge `default-args` и user args;
  - проверка наличия бинарника агента;
  - запуск фонового backup-процесса.
- `agsekit_cli/commands/*`
  - user-facing команды Click.
- `agsekit_cli/ansible/*`
  - playbooks для базовой подготовки VM, install bundles, установки агентов.

## 6. Конфигурационная модель

### 6.1 Где ищется конфиг
Порядок резолва:
1. `--config <path>`
2. `CONFIG_PATH`
3. `~/.config/agsekit/config.yaml`

### 6.2 Верхнеуровневые секции
- `vms` — описание виртуальных машин;
- `mounts` — описание монтируемых директорий и backup-политики;
- `agents` — описание агентных профилей запуска.

### 6.3 Секция `vms`
Каждая VM:
- `cpu` (обязателен) — число vCPU (положительное целое).
- `ram` (обязателен) — объём RAM (строка/число, например `4G`, `4096M`).
- `disk` (обязателен) — размер диска (строка/число).
- `cloud-init` (optional) — cloud-init mapping, передается в `multipass launch --cloud-init`.
- `proxychains` (optional) — URL прокси `scheme://host:port`.
  - допустимые схемы: `http`, `https`, `socks4`, `socks5`;
  - user/pass/path/query/fragment не допускаются.
- `port-forwarding` (optional) — список правил проброса портов.
  - `type=local`: открыть порт на хосте и пробросить в VM (`ssh -L host:vm`).
  - `type=remote`: открыть порт в VM и пробросить на хост (`ssh -R vm:host`).
  - `type=socks5`: поднять SOCKS5-порт в VM (`ssh -D vm`).
- `install` (optional) — список install bundles (`python`, `nodejs:20`, `docker`, ...), которые выполняются на этапе `create-vm/create-vms`.

### 6.4 Секция `mounts`
Поля mount entry:
- `source` (обязателен) — адрес монтируемой папки в хостовой файловой системе.
- `target` (optional, default `/home/ubuntu/<basename(source)>`) — адрес монтирования внутри VM.
- `backup` (optional, default `<source_parent>/backups-<basename(source)>`) — адрес папки резервных копий в хостовой файловой системе.
- `interval` (optional, default `5`, >0) — интервал инкрементальных резервных копий, в минутах.
- `max_backups` (optional, default `100`, >0) — максимальное количество снапшотов; после достижения лимита включается чистка старых.
- `backup_clean_method` (optional, default `thin`, одно из `tail|thin`) — метод очистки:
  - `tail`: удалять самые старые снапшоты (хвост истории), оставляя последние `N`;
  - `thin`: логарифмическое прореживание (больше плотности в свежем диапазоне, меньше в старом, но старые точки во времени тоже сохраняются).
- `vm` (optional) — VM для этого mount; если не задан, используется первая VM из `vms`.
- `allowed_agents` (optional) — список имён агентов из секции `agents` или строка имён, разделённых запятыми.
  - если поле задано, `run` из этого `source` (или любой подпапки) разрешён только для перечисленных агентов;
  - если поле отсутствует, ограничение не применяется.

Нормализация:
- пути приводятся к абсолютным через `expanduser().resolve()`;
- если путь в команде указывает на подпапку внутри `source`, выбирается наиболее специфичное совпадение (`longest-prefix`).
- `allowed_agents` валидируется как список непустых строк (из YAML-списка или строки `a, b, c`); каждое имя `strip`-ится и должно существовать в `agents`.

### 6.5 Секция `agents`
Поля:
- `type` (обязателен) — тип агента: `qwen`, `codex`, `codex-glibc`, `claude`.
  - runtime-бинарники: `qwen -> qwen`, `codex -> codex`, `codex-glibc -> codex-glibc`, `claude -> claude`.
  - `codex-glibc` — установка/сборка codex из исходников с установкой бинарника `codex-glibc`.
- `env` (optional) — mapping переменных окружения, передаваемых агенту при запуске.
  - значение приводится к строке (`null` -> пустая строка).
- `default-args` (optional) — список аргументов CLI по умолчанию.
  - при `run` одноимённые пользовательские опции переопределяют default-опции.
- `vm` (optional) — VM по умолчанию для агента; если нет, берётся первая VM.
- `proxychains` (optional) — proxy URL `scheme://host:port` для этого агента.
  - используется в `run` и `install-agents`;
  - если поле присутствует, оно перекрывает `vms.<vm>.proxychains` даже при пустой строке (т.е. может принудительно отключить proxychains для агента).

## 7. Модель CLI и взаимодействие режимов

### 7.1 Команды, которым конфиг НЕ требуется
Это список команд, которые могут работать без чтения project-конфига:
- `prepare`
- `backup-once`
- `backup-repeated`
- `config-example`
- `config-gen`
- `pip-upgrade`
- `version`
- `list-bundles`
- `systemd uninstall`

Важно:
- `systemd install` технически может быть вызван без существующего файла конфига (путь резолвится), но practically предназначен для сценария, когда конфиг уже есть, потому что service запускает `portforward`.

### 7.2 Команды, которые работают через конфиг
Практически все остальные команды читают и валидируют конфиг: VM lifecycle, mounts, agent install/run, backup по mount, порт-форвардинг.

### 7.3 Интерактивный режим (архитектурное решение)
Интерактивное меню не «высечено в камне»: это текущая организация команд для удобства пользователя и она может эволюционировать.

Сейчас команды в меню сгруппированы по секциям:
- init/config
- virtual machines
- mounts
- agents/shell
- daemon control
- manual backup

Поведение fallback:
- `agsekit` без аргументов в TTY -> открывает меню;
- если в TTY не хватает обязательных аргументов -> предлагает интерактивное заполнение;
- если команда требует конфиг, а файла нет -> предлагает интерактивно указать/создать путь;
- `--non-interactive` полностью отключает prompts.

## 8. Полное CLI-поведение с user-story контекстом

### 8.1 Подготовка хоста

#### `agsekit prepare`
Зачем пользователю:
- подготовить именно хостовую машину, чтобы дальше можно было стабильно создавать/готовить VM.

Что делает:
1. Проверяет наличие `multipass`.
2. Если `multipass` отсутствует:
   - ставит системные зависимости (Debian-based);
   - ставит Multipass через snap.
3. Проверяет/ставит Ansible collection `theko2fi.multipass`.
4. Создаёт SSH-ключи хоста в `~/.config/agsekit/ssh/` (используются для `ssh`/подготовки VM).

### 8.2 Создание конфигов

#### `agsekit config-example [destination]`
Зачем:
- быстро получить рабочий шаблон YAML-конфига на базе примера.

Что делает:
- копирует `config-example.yaml` в целевой путь;
- default path: `~/.config/agsekit/config.yaml`;
- если default already exists — пропускает копирование.

#### `agsekit config-gen [--config <path>] [--overwrite]`
Зачем:
- создать конфиг через мастер, без ручного редактирования YAML на старте.

Что делает:
- интерактивно собирает `vms`, `mounts`, `agents`;
- для агента запрашивает `type`, default `vm`, `env` и optional `proxychains`;
  - если для agent `proxychains` введено буквально `""`, в YAML сохраняется явная пустая строка (`proxychains: ""`);
- спрашивает путь сохранения;
- без `--overwrite` не перезаписывает существующий файл.

#### `agsekit pip-upgrade`
Зачем:
- обновить установленный `agsekit` в том же Python-окружении, где запущена CLI.

Что делает:
1. Проверяет, что `agsekit` установлен через `pip` в текущем окружении.
2. Считывает текущую версию через `pip show`.
3. Выполняет `pip install agsekit --upgrade`.
4. Повторно считывает версию и печатает итог:
   - если версия изменилась: `agsekit обновлён с версии X на версию Y`;
   - если версия не изменилась: `agsekit уже и так максимальной версии - X`.

### 8.2.1 Debug-режим для Multipass-команд

Для всех команд, которые взаимодействуют с `multipass`, поддерживается флаг `--debug`.

Что делает `--debug`:
- печатает запускаемую внешнюю команду;
- печатает код завершения;
- при наличии — печатает `stdout`/`stderr`.

Список команд с поддержкой `--debug`:
- `create-vm`, `create-vms`
- `start-vm`, `stop-vm`, `destroy-vm`
- `mount`, `umount`, `addmount`, `removemount`
- `install-agents`
- `run`
- `shell`, `ssh`
- `portforward`
- `status`

### 8.3 Мониторинг статуса

#### `agsekit status [--config <path>] [--debug]`
Зачем:
- получить единый «снимок состояния» инфраструктуры без ручного запуска нескольких команд.

Что делает:
1. Показывает путь конфигурации, который реально был использован (разрешение через `--config` / `CONFIG_PATH` / default path).
2. Для каждой ВМ из конфига выводит:
   - состояние в Multipass (running/stopped/absent);
   - ресурсы из конфига (CPU/RAM/Disk) и, при расхождении, фактические значения;
   - правила `port-forwarding` и статус процесса `agsekit portforward` (запущен/остановлен/неизвестно);
   - таблицу монтирований (`source`, `target`, `backup`, interval, retention/method, last backup, backups running?).
3. Для каждой ВМ выводит:
   - список агентов из конфига и их статус установки (по проверке бинарника в ВМ);
   - список запущенных агентных процессов (`PID`, бинарник, рабочая директория `cwd` и соответствующие имена из конфига).

Особенности:
- команда не запускает интерактивный запрос пути к конфигу; читает путь строго по стандартному порядку разрешения;
- эвристика `backups running?` считается положительной, если время последнего снапшота не старше `interval * 2`.
- в списке запущенных агентов скрываются дочерние процессы, если их родитель тоже распознан как агент (чтобы не дублировать один запуск несколькими PID).

### 8.4 Жизненный цикл VM

#### `agsekit create-vm [vm_name] [--debug]`
Зачем:
- поднять одну VM из конфига и довести её до состояния «готова для работы агента».

Что делает:
- выбирает VM (auto-select, если в конфиге одна);
- сравнивает существующую VM по `cpu/ram/disk`;
  - `cpu` сверяется строго;
  - `ram/disk` сверяются с допуском (относительный tolerance), потому что Multipass часто возвращает эффективный объём чуть меньше запрошенного;
- если VM отсутствует — создаёт;
- если параметры отличаются — сообщает mismatch (ресурсы не меняет);
- затем всегда запускает подготовку VM:
  - start;
  - sync SSH authorized_keys;
  - known_hosts;
  - install base packages;
  - install bundles.

#### `agsekit create-vms [--debug]`
- то же самое для всех VM из конфига.

#### `agsekit start-vm`, `stop-vm`, `destroy-vm` (`--debug` поддерживается)
Зачем:
- оперативное управление жизненным циклом VM.

Особенности:
- поддержка single/all режимов;
- если VM одна — имя можно не указывать;
- `stop-vm` выключает гостевую ОС изнутри через `multipass exec <vm> -- sudo poweroff`, ждёт 30 секунд и при незавершённом shutdown выполняет `multipass stop --force <vm>`;
- `destroy-vm` требует подтверждение (если нет `-y`), затем `delete` + `purge`.

### 8.5 Mount management

#### `agsekit mount [source_dir] [--all] [--debug]`
Зачем:
- примонтировать проект в VM перед запуском агента.

Особенности:
- поддержка выбора по точному и относительному пути;
- поддержка выбора по подпути внутри source;
- при already mounted выдает информативное сообщение и не падает.

#### `agsekit umount [source_dir] [--all] [--debug]`
- размонтирование по тем же правилам выбора mount.

#### `agsekit addmount [--debug]`
Зачем:
- добавить mount entry в YAML безопасно и без ручного редактирования.

Что делает:
- запрашивает/вычисляет default значения;
- показывает summary;
- в интерактивном режиме спрашивает подтверждение;
- делает timestamp backup конфига;
- сохраняет YAML с комментариями (`ruamel.yaml`);
- опционально выполняет mount сразу (`--mount`).

#### `agsekit removemount [--debug]`
Зачем:
- удалить mount entry безопасно и не оставить «битое» состояние.

Что делает:
- выбирает entry (по source, при необходимости по `--vm`, либо через prompt);
- сначала делает `umount`;
- только после успешного `umount` редактирует YAML;
- сохраняет backup конфига.

### 8.6 Backups

#### `agsekit backup-once --source-dir ... --dest-dir ...`
Зачем:
- сделать контролируемый моментальный снапшот каталога.

Алгоритм:
1. очистка старых `-partial/-inprogress`;
2. чтение `.backupignore` + `--exclude`;
3. dry-run на изменения;
4. при изменениях: rsync в `<timestamp>-partial`;
5. rename в финальный `<timestamp>`;
6. запись `.inodes`.

Поведение:
- если изменений нет — snapshot не создаётся;
- `--progress` показывает прогресс-бар;
- коды rsync `23/24` трактуются как warning, не fatal.

#### `agsekit backup-repeated`
Зачем:
- автоматически поддерживать backup-цепочку во время работы.

Что делает:
- запускает backup loop по интервалу;
- после каждого backup делает cleanup по политике;
- печатает ожидание следующего цикла;
- поддерживает `--skip-first`.

#### `agsekit backup-repeated-mount` / `backup-repeated-all`
- запускают repeated backup по mount-описаниям из конфига.

#### `agsekit backup-clean`
Зачем:
- ручная чистка backup-цепочки по mount.

Что делает:
- находит mount по source;
- применяет `tail` или `thin` с заданным `keep`.

Философский инвариант в текущей реализации:
- для команды `run` резервное копирование по mount включено по умолчанию;
- отключение возможно только явным флагом `--disable-backups` (осознанный opt-out).

### 8.7 Установка и запуск агентов

#### `agsekit install-agents [--debug]`
Зачем:
- установить agent CLI в VM через поддерживаемый playbook.

Что делает:
- выбирает агента(ов) и VM(ы);
- определяет playbook по `agents.<name>.type`;
- запускает Ansible installer;
- поддерживает proxy override на один запуск (`--proxychains`).

Инвариант CLI:
- установка агентов унифицирована и выполняется только через `install-agents` независимо от типа агента.

#### `agsekit run [--debug]`
Зачем:
- основной пользовательский сценарий: запустить агента внутри VM в нужной рабочей директории с безопасными backup-процессами.

Что делает:
1. определяет агента и VM;
2. определяет mount-контекст:
   - если передан `source_dir`, ищет mount по нему;
   - если `source_dir` не передан, пытается найти mount по текущей директории (`cwd`);
   - если mount не найден (и `source_dir` не передан), работает без mount-контекста;
3. определяет рабочую директорию в VM (на основе mount + относительного подпути или default home);
4. проверяет ограничение `mount.allowed_agents` (если задано);
5. проверяет наличие бинарника агента в VM;
6. (если backups enabled) делает initial backup при необходимости;
7. запускает фоновый `backup-repeated` и пишет лог в `backup.log`;
8. запускает агента через `multipass exec ... bash -lc`;
9. по завершении агента останавливает backup-процесс.

Инвариант CLI:
- запуск агентов унифицирован и выполняется только через `run <agent_name>` независимо от типа агента.

### 8.8 Операционный доступ и сервисный режим

#### `agsekit shell [--debug]`
- интерактивный вход в VM (`multipass shell`).

#### `agsekit ssh [--debug]`
- SSH в VM с ключом agsekit и прямой передачей доп. аргументов.

#### `agsekit portforward [--debug]`
- поднимает и мониторит SSH-туннели по `port-forwarding` правилам из конфига.

#### `agsekit systemd install/uninstall`
- `install`:
  - генерирует `~/.config/agsekit/systemd.env`;
  - регистрирует и включает user unit для `portforward`.
- `uninstall`:
  - останавливает/отключает/unlink unit.

Важно по отношению к философии проекта:
- текущая реализация systemd-юнита автоматизирует только `portforward`;
- более широкий daemon-контур (backups + agent-process supervision + централизованный статус) — это целевое направление развития, зафиксированное в `philosophy-ru.md` / `philosophy.md`.

## 9. Внутренние алгоритмы, критичные для поведения

### 9.1 Выбор mount по пути (longest-prefix)
- для `run`: входным путём служит явный `source_dir` либо `cwd`, если `source_dir` не задан;
- путь нормализуется (`resolve`);
- матчится либо точное совпадение, либо вложенность;
- при нескольких кандидатах выбирается наиболее специфичный (самый длинный `source`);
- при неоднозначности одинаковой глубины — ошибка.

### 9.2 Merge `default-args` с пользовательскими аргументами
- default-аргументы добавляются, если пользователь не передал одноимённую long-option;
- работает и для `--x=y`, и для split-формы `--x y`, и для флагов.

### 9.2.1 Маппинг `agent.type -> runtime binary`
- `run` и `status` используют runtime-бинарник, а не буквальное значение `type`;
- пока runtime-бинарник совпадает с `type`, но это может быть переопределено для новых агентов.

### 9.3 Проверка ресурсов при создании VM
Перед созданием новых VM:
- читаются существующие allocation (CPU/RAM) из `multipass list --format json`;
- суммируются планируемые ресурсы новых VM;
- запрещается создание, если останется меньше 1 CPU или меньше 1 GiB RAM.

### 9.4 Proxychains режим
- effective proxy определяется как `cli --proxychains override -> agents.<name>.proxychains -> vm.proxychains -> none`;
- helper scripts копируются в VM;
- helper scripts передаются в VM через `multipass exec ... bash -lc 'cat > ...'` по `stdin` (без чтения локального пути со стороны `multipass transfer`);
- создаётся временный proxychains config;
- команда запускается через `proxychains4`;
- в Ansible agent installers сетевые шаги выполняются через `proxychains_prefix` (без отдельного прокидывания proxy env-переменных).

### 9.5 Ограничение запуска по mount.allowed_agents
- если для выбранного mount указано `allowed_agents`, запуск разрешается только агентам из этого списка;
- проверка применяется для запуска по `source`, по подпапкам `source`, а также при автодетекте mount по `cwd`;
- при нарушении ограничения команда `run` завершается с ошибкой до старта агента и до запуска фоновых бэкапов.

## 10. Ansible-слой: что именно ставится

### 10.1 Базовая подготовка VM (`vm_packages.yml`)
- `git`
- `proxychains4`
- `ripgrep`

### 10.2 Install bundles (`vms.<vm>.install`)
Поддерживаемые bundles:
- `pyenv`
- `nvm`
- `python[:version]` (зависит от `pyenv`)
- `nodejs[:version]` (зависит от `nvm`)
- `rust`
- `golang`
- `docker`

Dependency resolution выполняется кодом до запуска playbooks.

### 10.3 Agent installers
- `codex.yml`: установка Node через nvm + `@openai/codex`.
- `qwen.yml`: установка Node через nvm + `@qwen-code/qwen-code`.
- `claude.yml`: установка через официальный install script; сетевые шаги выполняются через `proxychains_prefix`; если нативный post-install падает, применяется fallback-установка `claude` из уже скачанного бинарника в `~/.claude/downloads`.
- `codex-glibc.yml`: сборка из исходников `openai/codex`, управление swap при нехватке памяти, установка бинарника `codex-glibc`, post-build проверка.

## 11. Локализация

- Поддерживаемые языки: `en`, `ru`.
- Приоритет языка:
  1. `AGSEKIT_LANG`
  2. системная locale
  3. fallback: `en`
- Если ключ перевода отсутствует — возвращается сам ключ.

## 12. Побочные эффекты на диске

На хосте:
- `~/.config/agsekit/config.yaml`
- `~/.config/agsekit/ssh/id_rsa` и `id_rsa.pub`
- `~/.config/agsekit/systemd.env`
- backup snapshots `.../<timestamp>`
- временные backup dirs `*-partial` / `*-inprogress`
- `backup.log` для фоновых backup-процессов
- timestamp backups конфига при `addmount`/`removemount`

Внутри VM:
- временные proxychains helper scripts в `/tmp`
- установленный agent/toolchain stack по выбранным playbooks

## 13. Ограничения и текущие особенности

- Нельзя in-place менять `cpu/ram/disk` у уже созданной VM (только детект mismatch).
- `systemd install/uninstall` ожидает unit-файл `systemd/agsekit-portforward.service` в текущем рабочем каталоге.
- `addmount` не предлагает явный выбор VM поля entry; при резолве используется default VM логика.
- `shell` не включает автоматически порт-форвардинг; для постоянных туннелей используется `portforward`/`systemd`.
- Источником истины для текущего поведения являются код и тесты.

## 14. Влияние на развитие проекта

При доработке инструмента этот документ полезно читать как карту компромиссов:
- если меняется UX команд, нужно учитывать двойной режим (interactive + automation);
- если меняется структура конфига, нужно сохранить понятные defaults и миграционную предсказуемость;
- если меняется backup-логика, важно сохранить базовую user-гарантию: «запуск агента не оставляет пользователя без отката»;
- если добавляются новые типы агентов, нужно расширять и схему `agents.type`, и Ansible installers, и тестовое покрытие.
- если развивается observability/статус-интерфейс, нужно двигаться в сторону философской цели «прозрачность состояния» (VM, mounts, forward rules, backup health, активные процессы).
- если расширяется сервисный режим, нужно синхронизировать реализацию с философской целью более широкого system daemon orchestration.

Иными словами, `agsekit` — это не только набор команд, а операционная модель безопасной работы с агентами. Именно эта модель должна оставаться консистентной при любых будущих изменениях.
